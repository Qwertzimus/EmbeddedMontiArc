/**
 *
 *  ******************************************************************************
 *  MontiCAR Modeling Family, www.se-rwth.de
 *  Copyright (c) 2017, Software Engineering Group at RWTH Aachen,
 *  All rights reserved.
 *
 *  This project is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3.0 of the License, or (at your option) any later version.
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this project. If not, see <http://www.gnu.org/licenses/>.
 * *******************************************************************************
 */
/* generated from model null*/
/* generated by template symboltable.SymbolReference*/

package de.monticore.lang.embeddedmontiarc.embeddedmontiarc._symboltable;

import com.google.common.collect.ImmutableList;
import de.monticore.lang.monticar.mcexpressions._ast.ASTExpression;
import de.monticore.lang.monticar.si._symboltable.ResolutionDeclarationSymbol;
import de.monticore.lang.monticar.types2._ast.ASTUnitNumberResolution;
import de.monticore.symboltable.MutableScope;
import de.monticore.symboltable.Scope;
import de.monticore.symboltable.modifiers.AccessModifier;
import de.monticore.symboltable.references.CommonSymbolReference;
import de.monticore.symboltable.references.SymbolReference;
import de.monticore.symboltable.types.references.ActualTypeArgument;
import de.se_rwth.commons.logging.Log;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Optional;

/**
 * Represents a reference of {@link ComponentSymbol}.
 */
public class ComponentSymbolReference extends ComponentSymbol implements
        SymbolReference<ComponentSymbol> {

    protected final SymbolReference<ComponentSymbol> reference;
    private List<ActualTypeArgument> actualTypeArguments = new ArrayList<>();

    private List<ResolutionDeclarationSymbol> resSymbols = new ArrayList<>();
    private List<ASTExpression> arguments = new ArrayList<>();

    public ComponentSymbolReference(final String name, final Scope definingScopeOfReference) {
        super(name);
        reference = new CommonSymbolReference<>(name, ComponentSymbol.KIND, definingScopeOfReference);
        if (existsReferencedSymbol()) {
            setReferencedComponent(Optional.of(getReferencedSymbol()));

        }

    }


    public ComponentSymbolReference(final String name, final Scope definingScopeOfReference, EmbeddedMontiArcSymbolTableCreator emastc) {
        super(name);
        reference = new CommonSymbolReference<>(name, ComponentSymbol.KIND, definingScopeOfReference);
        if (existsReferencedSymbol()) {
            Log.debug("Loading resolution declarationSymbols", "info");
            setReferencedComponent(Optional.of(getReferencedSymbol()));
            resSymbols.addAll(reference.getReferencedSymbol().getResolutionDeclarationSymbols());

        } else {
            Log.debug("Reference to " + name + " does not exist", "info");

        }

    }


    public List<ResolutionDeclarationSymbol> getResDeclSyms() {
        return resSymbols;
    }

    @Override
    public List<ResolutionDeclarationSymbol> getResolutionDeclarationSymbols() {
        return resSymbols;
    }

    @Override
    public Optional<ResolutionDeclarationSymbol> getResolutionDeclarationSymbol(String name) {
        for (ResolutionDeclarationSymbol symbol : getResolutionDeclarationSymbols()) {
            if (symbol.getNameToResolve().equals(name))
                return Optional.of(symbol);
        }
        return Optional.empty();
    }

    @Override
    public boolean hasResolutionDeclaration(String name) {
        for (ResolutionDeclarationSymbol resDeclSym : resSymbols)
            if (resDeclSym.getNameToResolve().equals(name)) {
                return true;
            }
        return false;
    }

    @Override
    public int howManyResolutionDeclarationSymbol() {
        return resSymbols.size();
    }

    public void fixResolutions(EmbeddedMontiArcSymbolTableCreator emastc) {

        int count = 0;
        for (ResolutionDeclarationSymbol resDeclSym : getResolutionDeclarationSymbols()) {
            Log.debug("" + ((ASTUnitNumberResolution) getResolutionDeclarationSymbols().get(count).getASTResolution()).getNumber().get().intValue(), "resolus:");
            String lastNameStart = "";
            for (PortSymbol portSymbol : getIncomingPorts()) {
                Log.debug(portSymbol.getName(), "Found Port:");
                if (!portSymbol.getNameWithoutArrayBracketPart().equals(lastNameStart)) {
                    lastNameStart = portSymbol.getNameWithoutArrayBracketPart();
                    Log.debug(lastNameStart, "Found PortArray:");
                    Log.debug(portSymbol.getEnclosingScope().toString(), "PortArray enclosing scope:");
                    PortArraySymbol portArraySymbol = portSymbol.getEnclosingScope().<PortArraySymbol>resolve(lastNameStart, PortArraySymbol.KIND).get();
                    portArraySymbol.recreatePortArray(resDeclSym, emastc, this);
                }
            }
        }

        Log.debug("" + getIncomingPorts().size(), "incoming:");

        Log.debug("" + getOutgoingPorts().size(), "outgoing:");
    }

    public List<ActualTypeArgument> getActualTypeArguments() {
        return ImmutableList.copyOf(actualTypeArguments);
    }

    public void setActualTypeArguments(List<ActualTypeArgument> actualTypeArguments) {
        this.actualTypeArguments = new ArrayList<>(actualTypeArguments);
    }

    public boolean hasActualTypeArguments() {
        return this.actualTypeArguments.size() > 0;
    }

    // no overridden methods of ComponentSymbol as the ComponentSymbol itself checks whether it is a
    // reference or not.
  
  /* Methods of SymbolReference interface */

    @Override
    public ComponentSymbol getReferencedSymbol() {
        return reference.getReferencedSymbol();
    }

    @Override
    public boolean existsReferencedSymbol() {
        return reference.existsReferencedSymbol();
    }

    @Override
    public boolean isReferencedSymbolLoaded() {
        return reference.isReferencedSymbolLoaded();
    }

    @Override
    public List<ASTExpression> getArguments() {
        return arguments;
    }

    @Override
    public void addArgument(ASTExpression astExpression) {
        arguments.add(astExpression);
    }

    @Override
    public void setArguments(List<ASTExpression> arguments) {
        this.arguments = arguments;
    }

  /* Methods of Symbol interface */

    @Override
    public String getName() {
        return getReferencedSymbol().getName();
    }

    @Override
    public String getFullName() {
        return getReferencedSymbol().getFullName();
    }

    @Override
    public Scope getEnclosingScope() {
        return getReferencedSymbol().getEnclosingScope();
    }

    @Override
    public void setEnclosingScope(MutableScope scope) {
        getReferencedSymbol().setEnclosingScope(scope);
    }

    @Override
    public AccessModifier getAccessModifier() {
        return getReferencedSymbol().getAccessModifier();
    }

    @Override
    public void setAccessModifier(AccessModifier accessModifier) {
        getReferencedSymbol().setAccessModifier(accessModifier);
    }
}
